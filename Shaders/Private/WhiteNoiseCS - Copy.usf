#include "/Engine/Public/Platform.ush"

RWTexture2D<float4> OutputTexture;
float2 Dimensions;
uint TimeStamp;

// Parameters
float perceptionRadius = 5.0;
float maxSpeed = 0.1;
float separationWeight = 1.5;
float alignmentWeight = 1.0;
float cohesionWeight = 1.0;

uint NUM_BOIDS = 1000; // Adjust this to match the number of boids you're using

// Define the boid structure
struct Boid
{
    float3 position;
    float3 velocity;
};

// Buffer to store all boids
StructuredBuffer<Boid> boids : register(t0);
RWStructuredBuffer<Boid> boidsOut : register(u0); // Output for next frame

[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void MainComputeShader(uint3 DTid : SV_DispatchThreadID)
{
    Boid currentBoid = boids[DTid.x];

    float3 separationForce = float3(0, 0, 0);
    float3 alignmentForce = float3(0, 0, 0);
    float3 cohesionForce = float3(0, 0, 0);

    int count = 0;

    // Loop through all boids to determine the three forces
    for (uint i = 0; i < NUM_BOIDS; i++)
    {
        if (i != DTid.x) // Exclude self
        {
            float3 direction = boids[i].position - currentBoid.position;
            float distance = length(direction);

            if (distance < perceptionRadius)
            {
                // Separation
                separationForce -= normalize(direction) / distance;

                // Alignment
                alignmentForce += boids[i].velocity;

                // Cohesion
                cohesionForce += boids[i].position;

                count++;
            }
        }
    }

    if (count > 0)
    {
        // Average the forces
        separationForce /= count;
        alignmentForce /= count;
        cohesionForce /= count;

        // Cohesion force should point towards the average position
        cohesionForce = cohesionForce - currentBoid.position;
    }

    // Combine the forces (weights can be adjusted as needed)
    float3 force = separationWeight * separationForce + 
                   alignmentWeight * alignmentForce + 
                   cohesionWeight * cohesionForce;

    currentBoid.velocity += force;
    currentBoid.velocity = normalize(currentBoid.velocity) * maxSpeed;
    currentBoid.position += currentBoid.velocity;

    boidsOut[DTid.x] = currentBoid; // Store updated boid data
}
