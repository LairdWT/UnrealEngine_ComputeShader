#include "/Engine/Public/Platform.ush"

RWTexture2D<float4> VelocityOutputTexture;
Texture2D<float4> VelocityInput;
RWTexture2D<float4> PositionOutputTexture;
Texture2D<float4> PositionInput;
float2 TextureSize;
float Range;
float AlignScaler;
float CohesionScaler;
float SeparationScaler;

float3 HSVtoRGB(float h, float s, float v)
{
    float c = v * s;
    float x = c * (1.0 - abs(fmod(h / 60.0, 2.0) - 1.0));
    float m = v - c;

    float3 col;

    if (0 <= h && h < 60) {
        col = float3(c, x, 0);
    } else if (60 <= h && h < 120) {
        col = float3(x, c, 0);
    } else if (120 <= h && h < 180) {
        col = float3(0, c, x);
    } else if (180 <= h && h < 240) {
        col = float3(0, x, c);
    } else if (240 <= h && h < 300) {
        col = float3(x, 0, c);
    } else {
        col = float3(c, 0, x);
    }

    return col + m;
}

float3 RepeatDomain(float3 pos, float repeatSize)
{
    return frac(pos / repeatSize) * repeatSize - 0.5 * repeatSize;
}

float DE(float3 pos, out int iterations, out float3 lastZ, out float minDistToTrap)
{
    const float DOMAIN_SIZE = 3.0;  // Control the repetition size
    pos = RepeatDomain(pos, DOMAIN_SIZE);  // Apply domain repetition

    float powerTimeModulation = 8.0 + 3.0 * sin(0.25 * Range);
    const float POWER = powerTimeModulation;
    float3 z = pos;
    float dr = 1.0;
    float r = 0.0;
    const int MAX_ITERATIONS = 128;
    minDistToTrap = 1000.0;

    for(int i = 0; i < MAX_ITERATIONS; i++)
    {
        r = length(z);
        if (r > 2.0) 
        {
            iterations = i;
            lastZ = z;
            return 0.5 * log(r) * r / dr;
        }

        float theta = acos(z.z / r);
        float phi = atan2(z.y, z.x);
        dr = pow(r, POWER-1.0) * POWER * dr + 1.0;

        float zr = pow(r, POWER);
        theta *= POWER;
        phi *= POWER;

        z = zr * float3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
        z += pos;
        z += sin(0.25 * Range) * 0.005;

        float currentDistToTrap = length(z); // distance from the point to the origin
        minDistToTrap = min(minDistToTrap, currentDistToTrap);
    }

    iterations = MAX_ITERATIONS;
    lastZ = z;
    return 0.5 * log(r) * r / dr;
}

float AO(float3 pos, float3 nor)
{
    float occ = 0.0;
    float sca = 1.0;
    const float CONTRAST_FACTOR = 3.0;
    float3 dummyLastZ; 
    float dummyMinDistToTrap; 

    for (int i = 0; i < 32; i++)
    {
        float hr = 0.01 + 0.05 * float(i) / 4.0;
        float3 aopos = nor * hr + pos;
        int it;
        float dd = DE(aopos, it, dummyLastZ, dummyMinDistToTrap); 
        occ += -(dd - hr) * sca;
        sca *= 0.8;
    }
    return clamp(1.0 - occ * CONTRAST_FACTOR, 0.05, 1.0);
}

float3 GetColor(float minDistToTrap, int iters)
{
    float normalizedDist = 1.0 - clamp(minDistToTrap, 0.0, 1.0);
    float hue = fmod(iters + normalizedDist * 360.0, 360.0);
    float saturation = abs(sin(iters * 0.1)) + 0.5;
    return HSVtoRGB(hue, saturation, normalizedDist);
}

[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void MainComputeShader(uint3 DTid : SV_DispatchThreadID)
{
    float time = 2.0 * 3.14159265359 * frac(Range * 0.025);
    float3 cameraPos = float3(4.0 * sin(time), 2.0, 4.0 * cos(time));
    float3 targetPos = float3(0.0, 0.0, 0.0);
    float3 upVector = float3(0.0, 1.0, 0.0);

    float3 forward = normalize(targetPos - cameraPos);
    float3 right = cross(upVector, forward);
    float3 up = cross(forward, right);

    float3 rayDir = normalize(forward + 
                    (DTid.x / TextureSize.x - 0.5) * right + 
                    (DTid.y / TextureSize.y - 0.5) * up);

    const int MAX_RAY_STEPS = 128;
    const float MIN_DIST = 0.0025;
    const float MAX_DIST = 512.0;
    float depth = 0.1;

    float minDistToTrap = 100.0; 
    float3 lastZ;

    for(int i = 0; i < MAX_RAY_STEPS; i++)
    {
        float3 p = cameraPos + depth * rayDir;
        int iters;
        float d = DE(p, iters, lastZ, minDistToTrap);

        if (d < 0.25 * MIN_DIST * depth)  // Adaptive stopping criteria
        {
            float3 normal = normalize(float3(
                DE(p + float3(0.01, 0.0, 0.0), iters, lastZ, minDistToTrap) - DE(p - float3(0.01, 0.0, 0.0), iters, lastZ, minDistToTrap),
                DE(p + float3(0.0, 0.01, 0.0), iters, lastZ, minDistToTrap) - DE(p - float3(0.0, 0.01, 0.0), iters, lastZ, minDistToTrap),
                DE(p + float3(0.0, 0.0, 0.01), iters, lastZ, minDistToTrap) - DE(p - float3(0.0, 0.0, 0.01), iters, lastZ, minDistToTrap)
            ));

            float3 color = 1 - (GetColor(minDistToTrap, iters));
            color *= AO(p, normal);
            VelocityOutputTexture[DTid.xy] = float4(color, 1.0);
            return;
        }

        depth += d;

        if (depth >= MAX_DIST)
        {
            VelocityOutputTexture[DTid.xy] = float4(0.05, 0.10, 0.10, 1.0);
            return;
        }
    }

    VelocityOutputTexture[DTid.xy] = float4(0.05, 0.10, 0.10, 1.0);
}
